package org.firstinspires.ftc.teamcode.mechanisms;

import com.qualcomm.hardware.limelightvision.LLResult;
import com.qualcomm.hardware.limelightvision.Limelight3A;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.IMU;

import org.firstinspires.ftc.robotcore.external.navigation.Pose3D;
import org.firstinspires.ftc.robotcore.external.navigation.YawPitchRollAngles;

@TeleOp(name = "AprilTagLimeLight")
public class AprilTagLimeLight extends OpMode {

    private Limelight3A limelight;
    private IMU imu;

    private DcMotorEx frontLeft, frontRight, backLeft, backRight;

    // Control gains
    private final double kPForward = 0.05;   // forward/backward proportional gain
    private final double kPSide = 0.02;      // strafe proportional gain
    private final double stopDistanceInches = 6.0; // stop this far away from tag //var?

    // Limelight calibration values (tune these for your robot)
    private final double limelightMountAngleDegrees = 25.0; //var?
    private final double limelightLensHeightInches = 20.0; //var?
    private final double tagHeightInches = 60.0; //var?

    @Override
    public void init() {
        limelight = hardwareMap.get(Limelight3A.class, "LimeLight");
        limelight.pipelineSwitch(8); // AprilTag pipeline
        limelight.start();

        imu = hardwareMap.get(IMU.class, "imu"); // field orientation through imu
        RevHubOrientationOnRobot revHubOrientationOnRobot =
                new RevHubOrientationOnRobot(
                        RevHubOrientationOnRobot.LogoFacingDirection.FORWARD, //var?
                        RevHubOrientationOnRobot.UsbFacingDirection.FORWARD); //var?
        imu.initialize(new IMU.Parameters(revHubOrientationOnRobot));

        // motors bc Chassis is ?
        frontLeft = hardwareMap.get(DcMotorEx.class, "frontLeft");
        frontRight = hardwareMap.get(DcMotorEx.class, "frontRight");
        backLeft = hardwareMap.get(DcMotorEx.class, "backLeft");
        backRight = hardwareMap.get(DcMotorEx.class, "backRight");

        frontRight.setDirection(DcMotorEx.Direction.REVERSE);
        backRight.setDirection(DcMotorEx.Direction.REVERSE);
    }

    @Override
    public void loop() {
        YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();
        limelight.updateRobotOrientation(orientation.getYaw());

        LLResult llResult = limelight.getLatestResult();
        if (llResult != null && llResult.isValid()) {
            Pose3D botPose = llResult.getBotpose_MT2();
            double tx = botPose.getPosition().x; // horizontal offset (degrees)
            double ty = botPose.getPosition().y; // vertical offset (degrees)

            // distance calculation using the angle (limelight documentation)
            double angleToGoalDegrees = limelightMountAngleDegrees + ty;
            double angleToGoalRadians = Math.toRadians(angleToGoalDegrees); //convertion to radians
            double distanceInches = (tagHeightInches - limelightLensHeightInches) /
                    Math.tan(angleToGoalRadians);

            telemetry.addData("tx (deg)", tx);
            telemetry.addData("ty (deg)", ty);
            telemetry.addData("Distance (in)", distanceInches);

            //drive toward the tag if B is pressed
            if (gamepad1.b) {
                if (distanceInches > stopDistanceInches) {
                    // forward power based on distance
                    double forwardPower = (distanceInches - stopDistanceInches) * kPForward;
                    // to the side power based on horizontal offset
                    double strafePower = tx * kPSide;

                    // clip power to [-1, 1]
                    forwardPower = Math.max(-1.0, Math.min(1.0, forwardPower));
                    strafePower = Math.max(-1.0, Math.min(1.0, strafePower));

                    // drive (no rotation control)
                    double fl = forwardPower + strafePower;
                    double fr = forwardPower - strafePower;
                    double bl = forwardPower - strafePower;
                    double br = forwardPower + strafePower;

                    frontLeft.setPower(fl);
                    frontRight.setPower(fr);
                    backLeft.setPower(bl);
                    backRight.setPower(br);

                    telemetry.addData("Driving", "Toward Tag");
                } else {
                    stopMotors();
                    telemetry.addData("Status", "Reached target distance");
                }
            } else {
                stopMotors();
            }
        }

        telemetry.update();
    }

    private void stopMotors() {
        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }
}
